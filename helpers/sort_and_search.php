<?phpinclude 'global_helper.php';//统一由小到大排序//冒泡排序思路:第一次循环找出最小的放最前面,第二次循环找出第二小的,以此类推function bubble_sort($arr){    $len = count($arr);    for ($i = 1; $i < $len; $i++) {        for ($j = 0; $j < $len - 1; $j++) {            if ($arr[$j] > $arr[$j + 1]) {                $tmp = $arr[$j + 1];                $arr[$j + 1] = $arr[$j];                $arr[$j] = $tmp;            }        }    }    return $arr;}//选择排序思路:先假设第一个数最小,然后把后面每一个依次和第一个数比较,//小的就标记下标为$p,直到确定最小的那个数然后把它放到第一个位置,//在比较出除了第一个数以外的所有数中的最小放到第二,依次类推function select_sort($arr){    $len = count($arr);    for ($i = 0; $i < $len - 1; $i++) {        $p = $i;        for ($j = $i + 1; $j < $len; $j++) {            if ($arr[$j] < $arr[$p]) {                $p = $j;            }        }        if ($p != $i) {            $tmp = $arr[$p];            $arr[$p] = $arr[$i];            $arr[$i] = $tmp;        }    }    return $arr;}//插入排序思路:从第二个数开始,假设前面时排好序了,现在将第n个数插入前面已经排好序的有序数列中适当的位置,以此类推function insert_sort($arr){    $len = count($arr);    for ($i = 1; $i < $len; $i++) {        $tmp = $arr[$i];        for ($j = $i - 1; $j >= 0; $j--) {            if ($arr[$j] > $tmp) {                $arr[$j + 1] = $arr[$j];                $arr[$j] = $tmp;            } else {                break;            }        }    }    return $arr;}//快速排序思路：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，//一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分function quick_sort($arr){    $len = count($arr);    if ($len <= 1) {        return $arr;    }    $base_num = $arr[0];    $left_arr = [];    $right_arr = [];    for ($i = 1; $i < $len; $i++) {        if ($base_num > $arr[$i]) {            $left_arr[] = $arr[$i];        } else {            $right_arr[] = $arr[$i];        }    }    $left_arr = quick_sort($left_arr);    $right_arr = quick_sort($right_arr);    return array_merge($left_arr, array($base_num), $right_arr);}function merge_sort($arr){    $len = count($arr);    if ($len <= 1)        return $arr;    $half = ($len >> 1) + ($len & 1);    // $a >> $b表示将$a右移$b位,&按位与    $arr2d = array_chunk($arr, $half);    $left = merge_sort($arr2d[0]);    $right = merge_sort($arr2d[1]);    $reg = [];    while (count($left) && count($right))        if ($left[0] < $right[0])            $reg[] = array_shift($left);        else            $reg[] = array_shift($right);    return array_merge($reg, $left, $right);}function dichotomous_search($array, $find_value, $left_index = 0, $right_index = 0){    //判断数组元素的数量    if (count($array) != 0 and $right_index == 0) {      //判断是否为第一次调用        //数组的元素个数        $right_index = count($array);    }    if ($left_index <= $right_index) {      //如果还存在剩余的数组元素        $mid_index = intval(($left_index + $right_index) / 2);      //取$low 与$high的中间值        //return $array[$mid];        if ($array[$mid_index] == $find_value) {            return $mid_index + 1;    //如果找到则返回        } elseif ($find_value < $array[$mid_index]) {            //如果上面没有找到，则继续查找            return dichotomous_search($array, $find_value, $left_index, $mid_index - 1);        } else {            return dichotomous_search($array, $find_value, $mid_index + 1, $right_index);        }    }    return "没有要查找的值";}function order_search($arr, $find_value){    $flag = false;    for ($i = 0; $i < count($arr); $i++) {        if ($arr[$i] == $find_value) {            echo "顺序查找的ip位置为:第" . ++$i . "位";            $flag = true;        }    }    if (!$flag) {        return $flag;    }}